âœ… Summary: Pass-by-Value vs. Pass-by-Reference in C++
Here's a clear and simple summary of the two concepts, especially for when you're passing a struct like strInfo to a function such as PrintInfo.

ğŸ”¹ 1. Pass-by-Value
void PrintInfo(strInfo Info)
void PrintInfo(strInfo Info)
ğŸ“Œ What it does:
Makes a copy of the object.
The function works with that copy , not the original.
âœ… Pros:
Safe: Changes inside the function do not affect the original data.
Simple concept.
âŒ Cons:
Inefficient : Copies take memory and time.
Not good for large or complex data structures.
ğŸ”¹ 2. Pass-by-Reference

void PrintInfo(strInfo &Info)      // Can modify original
void PrintInfo(const strInfo &Info) // Cannot modify original
ğŸ“Œ What it does:
Works directly on the original object .
No copying happens â†’ faster and more efficient .
âœ… Pros:
Efficient : No copy is made.
Good for big objects (like structs with many fields).
Using const ensures safety (prevents accidental changes).
âŒ Cons:
If not using const, function can accidentally change the original data.
ğŸŸ© Best Practice for Your Case
Since your function only prints the data (doesnâ€™t change it), this is best:

void PrintInfo(const strInfo &Info)
You get the performance benefit of no copying .
You protect the original data by using const.
ğŸ§¾ Quick Comparison Table
ğŸ§¾ Quick Comparison Table
Copies object
âœ… Yes
âŒ No
Can change original data
âŒ No (itâ€™s a copy)
âœ… Yes (unless
const
)
Efficiency
âŒ Slower (due to copying)
âœ… Faster
Safety
âœ… Safer (original untouched)
âœ… Safe with
const
Best use case
Small/simple types
Large/complex types, read-only access
ğŸ¯ Final Answer
Use this version for printing:
cpp


1
void PrintInfo(const strInfo &Info)
Why?
Itâ€™s fast (no copying),
Itâ€™s safe (canâ€™t accidentally change data),
Itâ€™s the best practice in C++ for reading data.
